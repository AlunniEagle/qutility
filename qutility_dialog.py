# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QUtilityDialog
                                 A QGIS plugin
 Un toolbox multifunzione per QGIS
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-05-06
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Lorenzo Alunni
        email                : gis@eagleprojects.it
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import processing
import time
from qgis.PyQt import QtGui, QtWidgets, uic # type: ignore
from qgis.PyQt.QtCore import Qt # type: ignore
from qgis.core import (QgsProject, QgsVectorLayer, QgsVectorFileWriter, QgsField,
                       QgsMessageLog, Qgis, QgsMapLayer, QgsWkbTypes, QgsCoordinateReferenceSystem, QgsCoordinateTransform,
                       QgsProcessingContext, QgsProcessingFeedback)
from qgis.gui import QgsFileWidget
from qgis.PyQt.QtWidgets import QApplication, QMessageBox # type: ignore
from PyQt5.QtGui import QRegExpValidator
from PyQt5.QtCore import QVariant, QRegExp
from .layer_renamer import LayerRenamer
from .layer_loader import LayerLoader
from .feature_excluder import FeatureExcluder
from .batch_converter import BatchConverter

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'qutility_dialog_base.ui'))


class QUtilityDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QUtilityDialog, self).__init__(parent)
        # Set up the user interface from Designer
        self.setupUi(self)
        
        # Rimuove la barra di progresso
        # self.fmbar.setVisible(False)
        
        # Connetti i segnali
        self.fmlayerlist.itemSelectionChanged.connect(self.update_selection_count)
        self.fmlayerlist.itemSelectionChanged.connect(self.update_fields)
        self.fmrun.clicked.connect(self.modify_field)
        self.fmtype.currentIndexChanged.connect(self.toggle_precision_field)
        
        # Configurazione validatore per il campo fmname (solo caratteri letterali, numeri e underscore)
        regex = QRegExp("[a-zA-Z0-9_]+")
        name_validator = QRegExpValidator(regex, self)
        self.fmname.setValidator(name_validator)
        
        # Inizialmente disattiva il campo nome
        self.fmname.setEnabled(False)
        
        # Aggiungi connessione per attivare/disattivare fmname
        self.fmfield.currentTextChanged.connect(self.toggle_name_field)

        # Imposta i validatori per accettare solo numeri
        # Validatore per il campo lunghezza (solo numeri interi positivi)
        int_validator = QtGui.QIntValidator(1, 999, self)
        self.fmlun.setValidator(int_validator)
        
        # Validatore per il campo precisione (solo numeri interi non negativi)
        precision_validator = QtGui.QIntValidator(0, 99, self)
        self.fmpreci.setValidator(precision_validator)

        # Inizializzi i componenti
        self.layer_renamer = LayerRenamer(self)
        self.layer_loader = LayerLoader(self)
        self.feature_excluder = FeatureExcluder(self)
        self.batch_converter = BatchConverter(self)

        # Popola i tipi di campo
        self.populate_field_types()
        
        # Popola la lista dei layer
        self.populate_layers()
        self.layer_renamer.populate_layers()
        
        # Inizialmente disattiva il campo precisione
        self.fmpreci.setEnabled(False)
        
        # Connetti gli eventi di progetto
        QgsProject.instance().layersAdded.connect(self.on_layers_changed)
        QgsProject.instance().layersRemoved.connect(self.on_layers_changed)

        # Inizializzazione Overlaps Counter
        self.setup_overlaps_counter()

    def toggle_name_field(self, text):
        """Attiva/disattiva il campo nome in base alla selezione del campo
        e imposta un placeholder dinamico"""
        is_field_selected = bool(text)
        
        # Attiva/disattiva il campo nome
        self.fmname.setEnabled(is_field_selected)
        
        if not is_field_selected:
            # Se nessun campo è selezionato, pulisci il campo e il placeholder
            self.fmname.clear()
            self.fmname.setPlaceholderText("")
        else:
            # Se un campo è selezionato, imposta un placeholder dinamico
            # che indica all'utente che può lasciare vuoto per mantenere il nome originale
            self.fmname.setPlaceholderText(f"Lascia vuoto per mantenere '{text}'")

    def on_layers_changed(self):
        """Gestisce gli eventi di aggiunta/rimozione layer"""
        self.populate_layers()
        self.layer_renamer.populate_layers()
    
    def populate_layers(self):
        """Popola la lista dei layer vettoriali"""
        self.fmlayerlist.clear()
        
        # Ottieni tutti i layer dal progetto
        layers = QgsProject.instance().mapLayers().values()
        
        # Filtra solo i layer vettoriali
        for layer in layers:
            if isinstance(layer, QgsVectorLayer):
                item = QtWidgets.QListWidgetItem(layer.name())
                item.setData(Qt.UserRole, layer)
                self.fmlayerlist.addItem(item)
    
    def populate_field_types(self):
        """Popola il menu a tendina con i tipi di campo"""
        self.fmtype.clear()
        self.fmtype.addItem("String")
        self.fmtype.addItem("Integer")
        self.fmtype.addItem("Double")
        # self.fmtype.addItem("Date")
    
    def update_fields(self):
        """Aggiorna la lista dei campi"""
        self.fmfield.clear()
        selected_layers = self.get_selected_layers()
        
        if not selected_layers:
            return
        
        # Se c'è un solo layer, mostra tutti i suoi campi
        if len(selected_layers) == 1:
            layer = selected_layers[0]
            for field in layer.fields():
                self.fmfield.addItem(field.name())
        else:
            # Altrimenti mostra solo i campi comuni a tutti i layer
            common_fields = None
            
            for layer in selected_layers:
                fields = set(field.name() for field in layer.fields())
                
                if common_fields is None:
                    common_fields = fields
                else:
                    common_fields = common_fields.intersection(fields)
            
            if common_fields:
                for field_name in sorted(common_fields):
                    self.fmfield.addItem(field_name)
    
    def get_selected_layers(self):
        """Restituisce una lista dei layer selezionati"""
        selected_layers = []
        
        for item in self.fmlayerlist.selectedItems():
            layer = item.data(Qt.UserRole)
            if layer:
                selected_layers.append(layer)
        
        return selected_layers
    
    def toggle_precision_field(self):
        """Attiva/disattiva il campo precisione in base al tipo selezionato"""
        # Abilita il campo precisione solo se il tipo è Double
        self.fmpreci.setEnabled(self.fmtype.currentText() == "Double")
        
        # Se non è Double, pulisci il campo
        if self.fmtype.currentText() != "Double":
            self.fmpreci.setText("")

    def update_selection_count(self):
        """Aggiorna il conteggio dei layer selezionati"""
        selected_count = len(self.fmlayerlist.selectedItems())
        if selected_count > 0:
            self.fmrun.setText(f"  Applica modifiche ai Selezionati ({selected_count})")
        else:
            self.fmrun.setText("  Applica modifiche ai Selezionati")
    
    def modify_field(self):
        """Modifica il campo selezionato nei layer selezionati"""
        # Ottieni i layer selezionati
        selected_layers = self.get_selected_layers()
        if not selected_layers:
            QMessageBox.warning(self, "Warning", "Select at least one layer")
            return
        
        # Ottieni il campo selezionato
        field_name = self.fmfield.currentText()
        if not field_name:
            QMessageBox.warning(self, "Warning", "Select a field to modify")
            return
        
        # Ottieni il nuovo nome se specificato
        new_field_name = self.fmname.text().strip()

        # Se non è specificato un nuovo nome, usa il nome attuale
        if not new_field_name:
            new_field_name = field_name
        
        # Ottieni il nuovo tipo
        new_type = self.fmtype.currentText()
        
        # Ottieni la lunghezza
        try:
            new_length = int(self.fmlun.text()) if self.fmlun.text() else 255
            if new_length <= 0:
                raise ValueError()
        except ValueError:
            QMessageBox.warning(self, "Error", "Length must be a positive number")
            return
        
        # Ottieni la precisione (solo per Double)
        precision = 0
        if new_type == "Double":
            try:
                precision = int(self.fmpreci.text()) if self.fmpreci.text() else 0
                if precision < 0:
                    raise ValueError()
            except ValueError:
                QMessageBox.warning(self, "Error", "Precision must be a non-negative number")
                return
        
        # Chiedi conferma
        confirmation_message = f"Modify the field '{field_name}' in the selected layers?\n\n" \
                            "This operation may result in data loss if the conversion is not compatible.\n" \
                            "It is recommended to make a backup before proceeding.\n\n" \
                            f"New type: {new_type}\n" \
                            f"Length: {new_length}"

        if new_type == "Double":
            confirmation_message += f"\nPrecisione: {precision}"

        if new_field_name != field_name:
            confirmation_message += f"\nNuovo nome: '{new_field_name}'"
            
        reply = QMessageBox.question(
            self, 
            "Conferma", 
            confirmation_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if reply == QMessageBox.No:
            return
        
        # Disabilita i controlli
        self.fmrun.setEnabled(False)
        self.fmlayerlist.setEnabled(False)
        self.fmfield.setEnabled(False)
        self.fmtype.setEnabled(False)
        self.fmlun.setEnabled(False)
        self.fmpreci.setEnabled(False)
        
        # Crea e mostra il popup di elaborazione
        progress_dialog = QMessageBox(self)
        progress_dialog.setWindowTitle("Processing in progress")
        progress_dialog.setText("Modifying field in progress...\nDo not close QGIS.")
        progress_dialog.setStandardButtons(QMessageBox.NoButton)
        progress_dialog.setIcon(QMessageBox.Information)
        
        # Mostra il popup senza bloccare
        progress_dialog.show()
        QApplication.processEvents()
        
        # Determina il tipo QVariant
        if new_type == "String":
            qvariant_type = QVariant.String
        elif new_type == "Integer":
            qvariant_type = QVariant.Int
        elif new_type == "Double":
            qvariant_type = QVariant.Double
        elif new_type == "Date":
            qvariant_type = QVariant.Date
        else:
            qvariant_type = QVariant.String
        
        error_layers = []
        success_layers = []
        
        # Processa ogni layer
        for layer in selected_layers:
            try:
                # Aggiorna l'UI
                QApplication.processEvents()
                
                # Verifica l'indice del campo
                field_idx = layer.fields().indexFromName(field_name)
                if field_idx == -1:
                    error_layers.append(f"{layer.name()} (campo non trovato)")
                    continue
                
                # Crea un nome temporaneo per il nuovo campo
                temp_field_name = field_name + "_new"
                
                # Avvia la modifica
                if not layer.isEditable():
                    layer.startEditing()
                
                # Crea un nuovo campo con il nuovo tipo
                new_field = QgsField(temp_field_name, qvariant_type, new_type, new_length, precision)
                layer.addAttribute(new_field)
                layer.updateFields()
                
                # Ottieni l'indice del nuovo campo
                new_idx = layer.fields().indexFromName(temp_field_name)
                
                # Copia i valori
                for feature in layer.getFeatures():
                    try:
                        value = feature[field_idx]
                        # Controlla se il valore è NULL (None in Python)
                        if value is None or (isinstance(value, QVariant) and value.isNull()):
                            # Mantieni il valore NULL
                            layer.changeAttributeValue(feature.id(), new_idx, None)
                        else:
                            # Converti solo i valori non-NULL
                            if qvariant_type == QVariant.Int:
                                try:
                                    value = int(value) if value not in (None, "") else None
                                except (ValueError, TypeError):
                                    value = 0  # Fallback per conversioni errate
                            elif qvariant_type == QVariant.Double:
                                try:
                                    value = float(value) if value not in (None, "") else None
                                except (ValueError, TypeError):
                                    value = 0.0  # Fallback per conversioni errate
                            # Imposta il valore convertito
                            layer.changeAttributeValue(feature.id(), new_idx, value)
                    except Exception as e:
                        # Gestione errori di conversione senza interrompere
                        print(f"Errore nella conversione di un valore: {str(e)}")
                        continue
                
                # Elimina il vecchio campo
                layer.deleteAttribute(field_idx)
                layer.updateFields()
                
                # Prova a rinominare il campo
                try:
                    # Ottieni l'indice aggiornato dopo l'eliminazione del campo originale
                    updated_idx = layer.fields().indexFromName(temp_field_name)
                    layer.renameAttribute(updated_idx, new_field_name)
                except Exception:
                    # Se il rinomino fallisce, lasciamo il campo con il nome temporaneo
                    error_layers.append(f"{layer.name()} (rinomino fallito)")
                    layer.commitChanges()
                    continue
                
                # Salva le modifiche
                layer.commitChanges()
                
                # Aggiungi ai layer di successo
                success_layers.append(layer.name())
                
            except Exception as e:
                error_layers.append(f"{layer.name()} ({str(e)})")
                if layer.isEditable():
                    layer.rollBack()
        
        # Chiudi il popup di elaborazione
        progress_dialog.accept()
        
        # Riabilita i controlli
        self.fmrun.setEnabled(True)
        self.fmlayerlist.setEnabled(True)
        self.fmfield.setEnabled(True)
        self.fmtype.setEnabled(True)
        self.fmlun.setEnabled(True)
        self.toggle_precision_field()  # Riattiva/disattiva il campo precisione in base al tipo
        
        # Crea un messaggio di completamento dettagliato
        result_message = ""
        
        if success_layers:
            result_message += f"Modifica completata con successo per {len(success_layers)} layer:\n"
            result_message += "\n".join(f"- {layer}" for layer in success_layers)
        
        if error_layers:
            if result_message:
                result_message += "\n\n"
            result_message += f"Errori in {len(error_layers)} layer:\n"
            result_message += "\n".join(f"- {layer}" for layer in error_layers)
        
        if not result_message:
            result_message = "Nessun layer elaborato."
        
        # Mostra messaggio di completamento
        QMessageBox.information(self, "Completed", result_message)

        # Aggiorna la lista dei campi
        self.update_fields()
    
    def setup_overlaps_counter(self):
        """Inizializza i componenti per Overlaps Counter"""
        
        # Configura i combo box per i layer (solo layer lineari)
        from qgis.core import QgsMapLayerProxyModel
        
        # Imposta il filtro per mostrare solo layer vettoriali lineari
        self.lyr1_oc.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.lyr2_oc.setFilters(QgsMapLayerProxyModel.LineLayer)

        # Configura i checkbox per "Solo elementi selezionati"
        self.ckbox_lyr1_oc.setChecked(False)  # Predefinito: usa tutti gli elementi
        self.ckbox_lyr2_oc.setChecked(False)  # Predefinito: usa tutti gli elementi
        
        # Configura il widget per il file di output
        self.cartout_oc.setStorageMode(QgsFileWidget.SaveFile)
        self.cartout_oc.setDialogTitle("Seleziona file di output")
        
        # Popola il combo box dei formati di output
        self.formatout_oc.clear()
        self.formatout_oc.addItem("Shapefile (.shp)", "shp")
        self.formatout_oc.addItem("GeoPackage (.gpkg)", "gpkg")
        self.formatout_oc.addItem("GeoJSON (.geojson)", "geojson")
        self.formatout_oc.addItem("CSV (.csv)", "csv")
        
        # Imposta il formato predefinito
        self.formatout_oc.setCurrentText("Shapefile (.shp)")
        
        # Connetti il pulsante al metodo per eseguire il contatore di sovrapposizioni
        self.btn_oc.clicked.connect(self.run_overlaps_counter)
        
        # Connetti i segnali per aggiornare l'estensione del file di output
        self.formatout_oc.currentTextChanged.connect(self.update_output_extension)

        # Connetti i segnali dei layer per abilitare/disabilitare i checkbox
        self.lyr1_oc.layerChanged.connect(self.update_checkbox_states)
        self.lyr2_oc.layerChanged.connect(self.update_checkbox_states)
        
        # Imposta i filtri per il file di output basati sul formato selezionato
        self.update_output_extension()

        # Aggiorna lo stato iniziale dei checkbox
        self.update_checkbox_states()

    def update_output_extension(self):
        """Aggiorna l'estensione del file di output in base al formato selezionato"""
        
        format_text = self.formatout_oc.currentText()
        
        if "Shapefile" in format_text:
            self.cartout_oc.setFilter("Shapefile (*.shp)")
        elif "GeoPackage" in format_text:
            self.cartout_oc.setFilter("GeoPackage (*.gpkg)")
        elif "GeoJSON" in format_text:
            self.cartout_oc.setFilter("GeoJSON (*.geojson)")
        elif "CSV" in format_text:
            self.cartout_oc.setFilter("CSV (*.csv)")

    def update_checkbox_states(self):
        """Aggiorna lo stato dei checkbox in base ai layer selezionati"""
        
        # Controlla se i layer hanno delle selezioni attive
        layer1 = self.lyr1_oc.currentLayer()
        layer2 = self.lyr2_oc.currentLayer()
        
        # CONFIGURAZIONE DINAMICA DEI CHECKBOX:
        if layer1 and layer1.selectedFeatureCount() > 0:
            self.ckbox_lyr1_oc.setEnabled(True)
            self.ckbox_lyr1_oc.setText(f"Selected records only ({layer1.selectedFeatureCount()})")
        else:
            self.ckbox_lyr1_oc.setEnabled(False)
            self.ckbox_lyr1_oc.setChecked(False)
            self.ckbox_lyr1_oc.setText("Selected records only")

        if layer2 and layer2.selectedFeatureCount() > 0:
            self.ckbox_lyr2_oc.setEnabled(True)
            self.ckbox_lyr2_oc.setText(f"Selected records only ({layer2.selectedFeatureCount()})")
        else:
            self.ckbox_lyr2_oc.setEnabled(False)
            self.ckbox_lyr2_oc.setChecked(False)
            self.ckbox_lyr2_oc.setText("Selected records only")

    def run_overlaps_counter(self):
        """Esegue l'elaborazione Overlaps Counter"""
        try:
            # Importa il metodo dalla classe principale
            # Assumendo che self.parent sia l'istanza di QUtility
            parent_plugin = None
            
            # Cerca l'istanza del plugin QUtility
            from qgis.utils import plugins
            if 'qutility' in plugins:
                parent_plugin = plugins['qutility']
            
            if parent_plugin and hasattr(parent_plugin, 'run_overlaps_counter'):
                parent_plugin.run_overlaps_counter()
            else:
                QMessageBox.warning(self, "Error", "Unable to find processing method")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error starting processing: {str(e)}")